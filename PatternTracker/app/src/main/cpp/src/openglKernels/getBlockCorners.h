static const char *getBlockCorners_kernel =
"#version 310 es\n"
"\n"
"#extension GL_ANDROID_extension_pack_es31a : require\n"
"layout(local_size_x = 128, local_size_y = 8) in;\n"
"layout(std430, binding = 2) buffer D_ssbo {int D[];};\n"
"layout(std430, binding = 3) buffer C_ssbo {int C[];};\n"
"layout(std430, binding = 4) buffer purity_ssbo {int purity[];};\n"
"layout(std430, binding = 5) buffer pSz_step_ssbo {int pSz_step[];};\n"
"\n"
"void jointDetect(inout int px, inout int py, int w, int h, int sz_x);\n"
"bool checkRimCornerBool(int idx, int idy, int sz_x, int r_rim);\n"
"void checkRimCorner(int idx, int idy, int sz_x, int r_rim, inout int pcol1, inout int pcol2, inout int pcol3);\n"
"void shrinkBox(inout int px, inout int py, int w, int h, int sz_x);\n"
"void jointDetect(inout int px, inout int py, int w, int h, int sz_x);\n"
"\n"
"void main()\n"
"{	\n"
"	int sz_x = int((gl_NumWorkGroups.x*gl_WorkGroupSize.x));\n"
"\t\tint sz_y = int((gl_NumWorkGroups.y*gl_WorkGroupSize.y));\n"
"	\n"
"\t\tint idx = int(gl_GlobalInvocationID.x);\n"
"\t\tint idy = int(gl_GlobalInvocationID.y);\n"
"	\n"
"	int sz_step = pSz_step[0];\n"
"\n"
"	if(idx>=sz_x-5 || idy>=sz_y-5) return;\n"
"\t\t\n"
"\t\tint id, idbx, idby;\n"
"\t\tint colID;\n"
"\t\t\n"
"\t\tid = idy*sz_x+idx;\n"
"\t\tif(purity[id]==0) return;\n"
"\t\t\n"
"\t\tidx *= sz_step;\n"
"\t\tidy *= sz_step;\n"
"\t\tsz_x *= sz_step;\n"
"\t\tsz_y *= sz_step;\n"
"\t\t\n"
"\t\tint r_rim=7;\n"
"	\n"
"\n"
"\t\tif(checkRimCornerBool(idx, idy, sz_x, r_rim)){\n"
"\t\t\t\t// find corner\n"
"\t\t\t\tshrinkBox( idx, idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\tidx-=r_rim;\n"
"\t\t\t\tidy-=r_rim;\n"
"\t\t\t\tshrinkBox(idx, idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\t\n"
"\t\t\t\tjointDetect(idx, idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\t\n"
"\t\t\t\tid = idy*sz_x+idx;\n"
"\t\t\t\tC[id]=1;\n"
"\t\t}\n"
"\n"
"\t\t// check diagonally offset blocks\n"
"\t\tidx = int(gl_GlobalInvocationID.x);\n"
"\t\tidy = int(gl_GlobalInvocationID.y);\n"
"\t\t\n"
"\t\tidx = idx*sz_step + r_rim;\n"
"\t\tidy = idy*sz_step + r_rim;\n"
"\t\t\n"
"\t\tif(checkRimCornerBool(idx, idy, sz_x, r_rim)){\n"
"\t\t\t\t// find corner\n"
"\t\t\t\tshrinkBox(idx, idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\t\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\t\n"
"\t\t\t\tidx-=r_rim;\n"
"\t\t\t\tidy-=r_rim;\n"
"\t\t\t\tshrinkBox(idx, idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\t\n"
"\t\t\t\tjointDetect(idx, idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\t\n"
"\t\t\t\tid = idy*sz_x+idx;\n"
"\t\t\t\tC[id]=1;\n"
"\t\t}\n"
"}\n"
"\n"
"bool checkRimCornerBool(int idx, int idy, int sz_x, int r_rim)\n"
"{\n"
"\t\tint col1, col2, col3;\n"
"\t\tcol1=0;\n"
"\t\tcol2=0;\n"
"\t\tcol3=0;\n"
"\t\t\n"
"\t\tcheckRimCorner(idx, idy, sz_x, r_rim, col1, col2, col3);\n"
"\t\t\n"
"\t\tif((col1>0 && col2>0) && col3>0){return true; }\n"
"\t\t\n"
"\t\treturn false;\n"
"}\n"
"\n"
"void checkRimCorner(int idx, int idy, int sz_x, int r_rim, inout int pcol1, inout int pcol2, inout int pcol3)\n"
"{\n"
"\t\tint id, idbx, idby;\n"
"\t\tint c;\n"
"\t\tfor(int i=0;i<2*r_rim;i++){\n"
"\t\t\t\tidbx = idx+i;\n"
"\t\t\t\tidby = idy;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)pcol1=1;\n"
"\t\t\t\tif(c==2)pcol2=1;\n"
"\t\t\t\tif(c==3)pcol3=1;\n"
"\n"
"\t\t\t\tidbx = idx+i;\n"
"\t\t\t\tidby = idy+2*r_rim-1;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)pcol1=1;\n"
"\t\t\t\tif(c==2)pcol2=1;\n"
"\t\t\t\tif(c==3)pcol3=1;\n"
"\t\t}\n"
"\n"
"\t\tfor(int i=1;i<2*r_rim-1;i++){\n"
"\t\t\t\tidbx = idx;\n"
"\t\t\t\tidby = idy+i;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)pcol1=1;\n"
"\t\t\t\tif(c==2)pcol2=1;\n"
"\t\t\t\tif(c==3)pcol3=1;\n"
"\n"
"\t\t\t\tidbx = idx+2*r_rim-1;\n"
"\t\t\t\tidby = idy+i;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)pcol1=1;\n"
"\t\t\t\tif(c==2)pcol2=1;\n"
"\t\t\t\tif(c==3)pcol3=1;\n"
"\t\t}\n"
"}\n"
"\n"
"void shrinkBox(inout int px, inout int py, int w, int h, int sz_x){\n"
"\t\tint newLineCol[4];\n"
"\t\tint rimColCount[4];\n"
"\t\tint lineColCount[4][4];\n"
"\t\tint x,y;\n"
"\t\tx = px;\n"
"\t\ty = py;\n"
"\t\t\n"
"\t\tint id, xt, yt;\n"
"\t\tint c;\n"
"\t\tint c_edge1, c_edge2, c_edge1_old, c_edge2_old;\n"
"\t\t\n"
"\t\tfor(int i=0;i<4;i++)\n"
"\t\t{\n"
"\t\t\t\tnewLineCol[i]=0;\n"
"\t\t\t\trimColCount[i]=0;\n"
"\t\t\t\tfor(int j=0;j<4;j++)\n"
"\t\t\t\t{\n"
"\t\t\t\t\t\tlineColCount[i][j]=0;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\t// getting color counts for all sides\n"
"\t\t// top & bot\n"
"\t\tfor(int i=0;i<w;i++)\n"
"\t\t{\n"
"\t\t\t\tint j=0;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\trimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[0][c]++;\n"
"\t\t\t\t}\n"
"\t\t\t\tj=h-1;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\trimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[1][c]++;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t// left & right\n"
"\t\tfor(int j=0;j<h;j++)\n"
"\t\t{\n"
"\t\t\t\tint i=0;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\tif(j>0 && j<h-1)rimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[2][c]++;\n"
"\t\t\t\t}\n"
"\t\t\t\ti=w-1;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\tif(j>0 && j<h-1)rimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[3][c]++;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\t// shrinking - top bot left right\n"
"\t\tint flag_shrink=1;\n"
"\t\twhile(flag_shrink==1){\n"
"\t\t\t\tflag_shrink=0;\n"
"\t\t\t\t\n"
"\t\t\t\tif(h>1){ // top line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int i=0;i<w;i++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint j=1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(i==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(i==(w-1))c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=0;\n"
"\t\t\t\t\t\t\t\tint j=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=w-1;\n"
"\t\t\t\t\t\t\t\tj=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[0][t]>0 && rimColCount[t] == lineColCount[0][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0; // not ok to remove line\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[0][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[0][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tlineColCount[2][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[3][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\ty++;\n"
"\t\t\t\t\t\t\t\th--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}// top line\n"
"\n"
"\t\t\t\tif(h>1){ // bot line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int i=0;i<w;i++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint j=h-2;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(i==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(i==w-1)c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=0;\n"
"\t\t\t\t\t\t\t\tint j=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=w-1;\n"
"\t\t\t\t\t\t\t\tj=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[1][t]>0 && rimColCount[t] == lineColCount[1][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[1][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[1][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tlineColCount[2][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[3][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\th--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}// bot line\n"
"\t\t\t\t\n"
"\t\t\t\tif(w>1){ // left line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int j=0;j<h;j++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(j==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(j==h-1)c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=0;\n"
"\t\t\t\t\t\t\t\tint j=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=0;\n"
"\t\t\t\t\t\t\t\tj=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[2][t]>0 && rimColCount[t] == lineColCount[2][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[2][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[2][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\n"
"\t\t\t\t\t\t\t\tlineColCount[0][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[1][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tx++;\n"
"\t\t\t\t\t\t\t\tw--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}// left line\n"
"\t\t\t\t\n"
"\t\t\t\tif(w>1){ // right line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int j=0;j<h;j++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=w-2;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(j==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(j==h-1)c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=w-1;\n"
"\t\t\t\t\t\t\t\tint j=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=w-1;\n"
"\t\t\t\t\t\t\t\tj=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[3][t]>0 && rimColCount[t] == lineColCount[3][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[3][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[3][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\n"
"\t\t\t\t\t\t\t\tlineColCount[0][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[1][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tw--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t} // right line\n"
"\t\t\t\t\n"
"\t\t} // while\n"
"\t\t\n"
"\t\t// get center pixel\n"
"\t\tx += w/2;\n"
"\t\ty += h/2;\n"
"\t\t\n"
"\t\tpx = x;\n"
"\t\tpy = y;\n"
"}\n"
"\n"
"void jointDetect(inout int px, inout int py, int w, int h, int sz_x){\n"
"\t\tint x,y;\n"
"\t\tx = px;\n"
"\t\ty = py; \n"
"\t\t\n"
"\t\tint c;\n"
"\t\tint sz_win = 5; // it has to be <= r_rim\n"
"\t\tint id1, id2;\n"
"\t\t\n"
"\t\tint grad[11][11];\n"
"\n"
"\t\t// vertical gradient\n"
"\t\tfor(int i=-sz_win;i<sz_win;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win-1;j++){\n"
"\t\t\t\t\t\tid1 = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\tid2 = (y+j+1)*sz_x+(x+i);\n"
"\t\t\t\t\t\tif(D[id1]!=D[id2]){\n"
"\t\t\t\t\t\t\t\tgrad[sz_win+j][sz_win+i]=1;\n"
"\t\t\t\t\t\t\t\tgrad[sz_win+j+1][sz_win+i]=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tfor(int i=-sz_win;i<sz_win-1;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win;j++){\n"
"\t\t\t\t\t\tif(grad[sz_win+j][sz_win+i]==1){\n"
"\t\t\t\t\t\t\t\tid1 = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tid2 = (y+j)*sz_x+(x+i+1);\n"
"\t\t\t\t\t\t\t\tif(D[id1]!=D[id2]){\n"
"\t\t\t\t\t\t\t\t\t\tgrad[sz_win+j][sz_win+i]=2;\n"
"\t\t\t\t\t\t\t\t\t\tif(grad[sz_win+j][sz_win+i+1]==1)grad[sz_win+j][sz_win+i+1]=2;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tint col[4];\n"
"\t\tcol[1]=0;col[2]=0;col[3]=0;\n"
"\t\tint i0,j0,flag;\n"
"\t\tflag=0;\n"
"\t\tfor(int i=-sz_win;i<sz_win;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win;j++){\n"
"\t\t\t\t\t\tif(grad[sz_win+j][sz_win+i]==2){\n"
"\t\t\t\t\t\t\t\tcol[1]=0;col[2]=0;col[3]=0;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j-1)*sz_x+(x+i)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j+1)*sz_x+(x+i)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j)*sz_x+(x+i-1)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j)*sz_x+(x+i+1)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j)*sz_x+(x+i)]]++;\n"
"\t\t\t\t\t\t\t\tif(col[1]>0 && col[2]>0 && col[3]>0){flag=1;i0=i;j0=j;break;}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t\tif(flag==1)break;\n"
"\t\t}\n"
"\t\tif(flag==1){\n"
"\t\t\t\tpx=x+i0;\n"
"\t\t\t\tpy=y+j0;\n"
"\t\t}\n"
"}\n"
;
